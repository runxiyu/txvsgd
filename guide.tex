\documentclass{extbook}

\usepackage{manfnt}

\title{Bruh}
\author{Paul Sutton (\texttt{zleap}) and Andrew Yu}

\setlength\parindent{2.3\parindent}

\makeatletter
% Dangerous Bend - Please only use this when there are two lines of text in the dangerous paragraph!
\def\hang{\hangindent \parindent}
\def\d@nger{\medbreak\begingroup\clubpenalty=10000
  \def\par{\endgraf\endgroup\medbreak} \noindent\hang\hangafter=-2
    \hbox to0pt{\hskip-\hangindent\dbend\hfill}\normalsize}
\outer\def\danger{\d@nger}
\def\dd@nger{\medbreak\begingroup\clubpenalty=10000
  \def\par{\endgraf\endgroup\medbreak} \noindent\hang\hangafter=-2
    \hbox to0pt{\hskip-\hangindent\dbend\kern1pt\dbend\hfill}\normalsize}
\outer\def\ddanger{\dd@nger}
\def\enddanger{\endgraf\endgroup}

\newcommand\ph[1]{\texttt{\textit{#1}}}
\makeatother

\begin{document}
\maketitle

\frontmatter
\chapter{Preface}

This project has developed from a series of posts on a personal blog site run by zleap. This is a refactoring of that content.  This will initially focus on helping people learn the command line for the GNU / Linux operating system.

This is a big subject area, I am going to start off with a series of posts to take this back to basics, starting off with learning about the command line in modern UNIX-like operating systems and associated commands using the \texttt{bash} shell.  Then move on to scripting using Bash. 

Although most commands and tips will work on all UNIX-like operating systems, some less common usages and options of these utilities may be absent on some systems.  This series focuses on usage of the GNU core utilities with occasional commands from util-linux, as GNU/Linux systems are the most common Free Software setups.  Users of other UNIX-like operating systems may consult their system manual for specifics into a command.

This guide is intended for beginners, as some sort of a semi-gentle introduction.  However, people with experience already may also find this guide helpful, and as such this guide will cover some 'more advanced' topics.  In order to make it possible for many types of readers to read this guide effectively, the  sign
$$\vbox{\hbox{\dbend}\vskip 11pt}$$
is put at the beginning of some paragraphs to indicate a "hard level".  If you are new to GNU/Linux systems and it's your first few reads, it is advised to skip these parts.  (Yes, this is the ``{dangerous bend}'' sign that Donald Knuth uses.)

\tableofcontents

\mainmatter
\chapter{Preparing the Environment}

$$\vcenter{\hbox{\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend\kern1pt\dbend}\vskip 11pt}$$
This chapter needs to be rewritten.

Firstly, we need access to a GNU/Linux system, there are numerous options here:

\begin{itemize}
    \item Install GNU/Linux on your computer;
    \item Purchase (or otherwise obtain) computers that use GNU/Linux "by default" or has mainline support thereof, such as:
    \begin{itemize}
        \item BeagleBone boards (https://beagleboard.org)
        \item Raspberry Pis (https://www.raspberrypi.org/)
        \item Orange Pi (http://www.orangepi.org/)
    \end{itemize}
    \item Install GNU/Linux in a virtual machine;
    \begin{itemize}
        \item Virtial Box (https://www.virtualbox.org/)
    \end{itemize}
    \item Use a public-access GNU/Linux system, such as \texttt{tilde.team};
    \item Use a browser-based emulator such as \texttt{https://bellard.org/jslinux/}
    \item \textit{et cetera}.
\end{itemize}

You could also join or help setup a local group such as 

\begin{itemize}
\item CodeClub ( https://www.codeclub.org.uk )
\item CoderDojo ( https://coderdojo.com/ )
\end{itemize}

\chapter{Getting support with this series}

You can get some help via IRC (Internet Relay Chat) myself (zleap) Ron (noisytoot), AnndrewYu (Andrew) all hang out on IRC.  There are several ways to connect to this via a client. it is probably easier, at least in the first instance to use a web based interface. 

\begin{enumerate}
\item go to https://libera.chat/
\item Click connect -> Webchat
\item Enter a nickname
\item In Channel enter \#phillw
\item Click start
\end{enumerate}


\chapter{Shell Basics}

We will be mainly working in the \texttt{bash} shell in this series.  GNU \texttt{bash} is the most common shell in modern GNU/Linux systems, which is the primary focus of this series.

A \textit{shell} is, in general, the program that you interact with your computer with.  When used in a more specific context it refers to a command-line shell that users type commands to.  The shell usually does some interpretation on the user input and passes these options launching a program, or they modify the shell's internal environment.

Many users, mostly novice ones, are afraid of command-line interfaces as the sterotypical UNIX command-line is very terse.  In rare fields this is still true, but things are generally better than in the old days.  For example, visual text editors are widespread among users of bitmap displays and terse teletype-oriented ones like \texttt{ed} are fading away.

Some may ask why the command-line is in consideration at all as we have graphical interfaces that are much more user-friendly.  It boils down to the fact that graphical interfaces are usually harder to extend for more features and for specific uses, and even in these cases where you would extend a GUI, knowledge of programming is still necessary, which would be similar to shell scripting.  In most cases simple scripts would be easier to write anyway; besides, using the shell day-to-day gives you confidence when you need to write batch operations---and believe me, it made my life much easier.

Now, go ahead and open up a shell.  On graphical systems, look for a program called ``Terminal'' or similar.  If you see something similar to ``\verb|user@host:~\$|'', ``\verb|[user@host ~] $|'', \textit{et cetera}, you're good to go!

\section{What is GNU}

As we are talking about GNU Bash, it makes sense to quickly explain what GNU is.   GNU stands for GNUs Not Unix,  GNU tools are the tools that came with the original Unix operating system, rewritten and released under the GNU General Public License. 

https://www.gnu.org/

\begin{itemize}
\item Freedom to use for any purpose
\item Freedom to study the software
\item Freedom to modify
\item Freedom to copy and share the software with others
\end{itemize}

\section{Interpretting the Prompt}

When you see something like ``\verb|user@host:~\$|'' or ``\verb|[user@host ~] $|'', the shell is waiting for you to type a command.

The default prompt on most systems consists of four parts:
\begin{enumerate}
	\item Your username;
	\item Your computer's hostname;
	\item Your current working directory;
	\item An actual prompt, which is ``\verb|$|'' for normal users and ``\verb|#|'' for root, the superuser.
\end{enumerate}

\danger{The ``\verb|#|'' prompt actually signifies a UID of \verb|0|.  If you have a setup where a user that is not ``\verb|root|'' has a UID of \verb|0| (and in this case such a user also has escalated privileges, because it's the UID rather than the username that matters, though most programs are not designed to work like this and can cause issues), its default prompt would also be ``\verb|#|''.}

Just know that such a prompt means that ``the last command (if any) has finished and the shell is waiting for a command''.

\section{Reading the Manual}

The system manual is a good resource for almost any command.  To access the system manual, you may use the \verb|man| command.

Now try it!  Type \verb|man| and press the Enter/Return key on your keyboard.
\begin{verbatim}
user@host:~$ man
What manual page do you want?
For example, try 'man man'.
user@host:~$ 
\end{verbatim}

It looks like that the computer is telling you that \verb|man| doesn't know what manual page to look up \ldots You should think of some keyword to tell \verb|man| to look up as \verb|man| allows you to view specific pages in the system manual.  Usually, the entrys' names are the name of the program, system call names, standard library function names, file formats (specifically filenames), etc.  They are divided into a few sections, which you should read more about with \verb|man man|, i.e. asking the system manual about the manual utility itself.  It is wise use the system manual for the command in interest before asking for support---because many times the manual solves your problems, and people don't like repeating a documented solution all the time, hense the ``Read the F* Manual'' ``meme'' spreading around.

When you encounter something that you want to do but you're not sure which command to use, the \verb|apropos| command is useful.  \verb|apropos| searches the manual database's page names and summary lines for your search term.  For example, if you're looking for a utility to print a file (which is usually \verb|lpr| or \verb|lp|, by the way), you could run \verb|apropos print|, and you'll be presented with a list of related manual entries (though do note how the term ``print'' is used for ``output text onto the screen'' besides ``tell the printer to put ink (or powder) onto paper'' for historical reasons).  Since you're looking for a \emph{command} to print, you'd generally want to look in section~1 of the manual (those marked with ``\verb|(1)|'').

Sometimes, you are not looking for the command of an external program, but rather a shell builtin, such as ``\verb|cd|''.  In this case, you should use the ``\verb|help|'' command instead of ``\verb|man|''.

\danger{You may have encountered the ``\verb|info|'' command as a system manual command.  That is part of the GNU \TeX info manual system, not the traditional UNIX manual system.  If you are looking for the manual of GNU utilities, such as ``\verb|bash|'', the \TeX info manuals will be more comprehensive than the manpages, and will generally include more examples and friendly information than what manpages will tell you.  However, not many programs outside of GNU utilities have \TeX info manuals.}

\section{File Operations}

Your UNIX-like operating system has a directory structure, and files are the center of UNIX-like operating systems.  Therefore, learning how to navigate the filesystem and handle files is important.

\subsection{Working Directory}

In any process, there is a \textit{current working directory}.  Any filenames that do not begin with a ``\verb|/|'', i.e. those that are not absolute paths, are relative to the process's current working directory.  At your shell prompt, you can use the ``\verb|pwd|'' ( present working directory ) command to know your current working directory.  This might not seem useful at first as your shell prompt already lists your current working directory, but in the future it will be useful in scripts, where you want to do something like ``save the current location to a variable and return to it sometime later''.

You would see that your shell prompt says that ``\verb|~|'' is your working directory, while ``\verb|pwd|'' says something like ``\verb|/home/user/|''.  That's because ``\verb|~|'' is an abbreviation to your user's \textit{home directory}, which is usually where you land when you login and is the place a user stores their personal files.

\subsection{Listing Files}

To list the files and directories of a given directory, use ``\texttt{ls \ph{directory}}''.  This lists all the items inside \ph{directory}.  If \ph{directory} is unspecified, it lists the current working directory by default.

By default, \verb|ls| does not list hidden files, i.e. files whose filename beings with a dot (``\verb|.|'').  If you pass the ``\verb|-a|`` option to it, hidden files are now listed.  Note that (``\verb|.|'') and (``\verb|..|'') as independent filenames mean ``current directory'' and ``parent directory'' respectively.

By default, \verb|ls| only lists the filenames of the files.  You may want more information.  To get more information, you may pass the ``\verb|-l|'' option, which lets \verb|ls| display extra information like filesystem permissions, file sizes (default unit is bytes, use ``\verb|-h|'' for adaptive units), modification dates, \textit{et cetera}.

\subsection{Reading Files}

You may use the ``\verb|cat|'' command to output the data in a specified filename onto ``\verb|cat|'''s standard output (usually the terminal).  If multiple filenames are specified as arguments, the files are concatenated.

While the ``\verb|cat|'' command can be used to read files, if the file is long then the output of cat will just scroll the contents up the screen.  The ``\verb|less|'' command displays the file content, but allows user interaction to display the file a page at a time.

If you are using ``\verb|less|'' you can press ``\verb|q|'' to quit and return to the bash prompt. 

\subsection{Creating Files}

To create a file, you can use the ``\verb|touch|'', in this case ``\verb|touch file.txt|'' will create an empty file called file.txt.

``\verb|touch|'' will also allow you to create multiple files, for example ``\verb|touch file.txt file2.txt file3.txt|''

To work with longer files, you can use editors such as ``\verb|nano|'' can also be used so ``\verb|nano file.txt|'' will either open an existing file or create a new file with that file name.   You can then edit the file contents.

You can also create files by directing the output of one command in to another.  For example, we have previosuly discussed the ``\verb|ls|'' command, so using ``\verb|ls > filelist.txt|'' will direct the output of ``\verb|ls|'' in to a file called ``\verb|filelist.txt|''.  Note that this truncates (i.e. clear) filelist.txt before redirecting the stream.  If you want to append instead, use ``\verb|>>|'' instead of ``\verb|>|''.

\danger{It is a bad idea to parse the output of \verb|ls| in scripts.  \verb|ls| uses special output formats (dollar symbol notations) and has other caveats for strange filenames.  Evaluating the output is potentially a security risk, too.  Batch operatings should either use shell wildcard or the ``\verb|find|'' command for better robustness.}

\subsection{File manipulation}

Bash allows you to move, copy and rename files.   

``\verb|cp|'' copy a file
``\verb|mv|'' move a file or this will also rename a file
``\verb|rename|'' This allows you to rename a file or set of files.  Very useful for batch renaming for example:-
``\verb|rename 's/DSCF/newname/' *|'' will take a set of files in this case starting with DSCF and replace that with newname.  If you have lots of files on your camera DSCF is an exanple of a prefix at the start of each photo filename.   If you go to the beach you may want to rename that to beach for example, so that set of photos can be idenfied later.   It just renames that portionof the file, so the numerical part remains intact.  
``\verb|rm|'' remove or delete a file
``\verb|mkdir|'' create a directory
``\verb|rmdir|'' remove or delete a directory

\subsection{File Permissions}

File permissions are an important security feature in any Unix type envirionment.  Files can either be Read, Write or Executable (e.g a shell script).  Depending on who you want to be able to access these files,  a file can either be just for the user who created it, a group of users, or anyone else.  

The two main commands that are important here are

``\verb|chmod|'' - Changes the file permission, to determine what can be done with it. 
``\verb|chown|'' - Changes the file owner

\begin{table}[h]
\begin{tabular}{|ccc|ccc|ccc|}
\hline
\multicolumn{3}{|c|}{\textbf{USER}}                               & \multicolumn{3}{c|}{\textbf{GROUP}}                              & \multicolumn{3}{c|}{\textbf{OTHER}}                              \\ \hline
\multicolumn{1}{|c|}{Read} & \multicolumn{1}{c|}{Write} & Execute & \multicolumn{1}{c|}{Read} & \multicolumn{1}{c|}{Write} & Execute & \multicolumn{1}{c|}{Read} & \multicolumn{1}{c|}{Write} & Execute \\ \hline
\multicolumn{1}{|c|}{400}  & \multicolumn{1}{c|}{200}   & 100     & \multicolumn{1}{c|}{40}   & \multicolumn{1}{c|}{20}    & 10      & \multicolumn{1}{c|}{4}    & \multicolumn{1}{c|}{2}     & 1       \\ \hline
\end{tabular}
\end{table}


\subsection{Finding Documents and Files}

The ``\verb|find|'' command will allow you to locate a file or set of files on you system.  Basic usage is ``\verb|find -n "file.txt" |''

If you want to find where a particular command is on your system you can use ``\verb|which|''.  So an example of ths could be ``\verb|which bash|'' the command will then return ``\verb|/usr/bin/bash|''

\subsection{User accounts and passwords}

It is sometimes necessary to add a new user to your system, or remove a user, you can also change a users password if they forget what it is.

\begin{itemize}
\item ``\verb|adduser|'' - add a new user to the system
\item ``\verb|useradd|'' - add a user to a group
\item ``\verb|deluser|'' - delete a user from the system
\item ``\verb|groupdel / delgroup|'' - manage groups on the system
\item ``\verb|passwd|'' - used on Debian and Debian derived systems e.g Ubutnu, Mint
\end{itemize}

As previously mentioned the \item ``\verb|man|'' can be used to find out more information about each of these. 

\subsection{Managing Software}

Depending on what distribution you are using, there are several tools that can be used to install or remove software on a GNU / Linux system.  

\begin{itemize}
\item ``\verb|apt|'' - used on Debian and Debian derived systems e.g Ubutnu, Mint
\item ``\verb|yum|'' - Used with suse 
\item ``\verb|rpm|'' - used with Red hat, Fedora 
\end{itemize}

\subsection{System Administration}

System administration is important.  It helps you monitor users, monitor resources etc.
\begin{itemize}
\item[``\texttt{ps}''] lists running processes on your system
\item[``\texttt{top}''] displays processes and allows them to be killed, or change their process priority
\item[``\texttt{nice \& renice}''] - change process priority
\item[``\texttt{htop}''] more advanced version of top
\item[``\texttt{killall}''] kills a process e.g killall firefox-esr
\item[``\texttt{cron}''] Run a process at a specified time
\item[``\texttt{su}''] Drop to super user - Maintain current user path*
\item[``\texttt{su}''] - Drop to super use,  using the root users path* 
\item[``\texttt{sudo}''] super user do,  drop to root to just run one command.
\item[``\texttt{reboot}''] restarts the system
\end{itemize}


\subsection{The Path Environment}
 In the previous subsection I mentioned the ``\verb|su|'' and ``\verb|su -|'' lets have a quick look at how the path environment compares,  we can view the current path with ``\verb|echo $PATH|''
\begin{itemize}
\item This is the user path /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
\item This is the root path when using ``\verb|su|'' /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
\item This is the root path when using ``\verb|su -|'' /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin
\item 
\end{itemize}

The difference is mostly that using ``\verb|su -|'' you won't get file not found when trying to run a command that is reserved for the root user. 

\subsection{Restarting an unresponsive system}

This may also be useful - \url{http://tuxdiary.com/2012/06/05/reiub-reset-unusable-linux-box/}

\subsection{Videos}

John Collins from ( https://www.ezeelinux.com/ ) produced an excellent series of videos covering different topics relating to the BASH shell,  We have only touched on this above.

These are hosted on Youtube.  For the purpose of this series, the links use the privacy friendly front end on Invideous:-

\begin{itemize}
\item [Access and Navigation] https://invidious.snopyta.org/watch?v=eH8Z9zeywq0 
\item [Creating \& Editing Text FIles] https://invidious.snopyta.org/watch?v=eH8Z9zeywq0 
\item [Privileges and Permissions] https://invidious.snopyta.org/watch?v=s23NqWKxOXk 
\item [Finding Documentation and Files] https://invidious.snopyta.org/watch?v=4r7V2-EBnR0 
\item [User Accounts and Passwords] https://invidious.snopyta.org/watch?v=XVCf0cou6EU 
\item [Managing Software] https://invidious.snopyta.org/watch?v=lNyJllHk2SA 
\item [System Administration Tools] https://invidious.snopyta.org/watch?v=4\_21KZ3qKEI7 
\item [Bash Scripting] https://invidious.snopyta.org/watch?v=57sp8Y0GL40 
\end{itemize}


\section{Editing files}

The nano editor is installed on pretty much every GNU / Linux system,  therefore it does make a good starting point, if we want to keep things simple.  So before moving on to shell scripting, we should learn howto use this, or at least, open, save and edit files. 

\begin{itemize}
\item https://www.nano-editor.org/
\item Youtube video - beginners guide to nano https://www.youtube.com/watch?v=cLyUZAabf40
\item Nano Cheat sheet - ( https://www.nano-editor.org/dist/latest/cheatsheet.html )

\end{itemize}

\section{Shell Scripting}

Once you have become more used to the command line interface, a shell script can make running the more labour intensive tasks much easier.  A shell script is a list of commands within a text file, which will can be run manually or perhaps run at a set time on your system.

\subsection{Getting Started}


\subsection{Checking who you are}

Depending on the script being run and its function, you may want to check the user is running the script as root.  

``\verb|
if [ "$EUID" -ne 0 ]
  then echo "Please run as root / sudo"
exit

  else
|''

\chapter{Next Steps}

\section{Networking}

https://www.youtube.com/watch?v=\_IOZ8\_cPgu8
https://invidious.snopyta.org/watch?v=\_IOZ8\_cPgu8

\begin{itemize}
\item a switch
\item router
\item gateway
\item subnet
\item gateway
\item firewall
\item DMZ
\end{itemize}

\section{Git}

\section{OpenSSH}

OpenSSH is a part of a suite of tools that allow secure remote access to systems.  

https://www.openssh.com/

By running OpenSSH you can enable remote access, remote file transfer etc. 

\section{Self Hosting}

Andew Yu has produced a really good guide to self hosting,  this can be found at

https://host.andrewyu.org/

This covers :

\begin{itemize}
\item Get a domain name
\item Get a server
\item Set up DNS settings to connect your server and domain name
\item Set up your web server
\item Get a secure HTTPS connection with Certbot
\end{itemize}

Common network ports - https://networkverge.com/common-ports/

\section{Gaming}

Gaming may not be something that seems related to this, however multiplayer games do generally need someone to host the game on a server.

Libre gaming night - https://libregaming.org/
There is a related IRC Channel

\#libregamenight

This is a regular event where people can get together to run multiplayer games,  so it makes sense to also include this, for anyone who would like to host their own game servers. 

\end{document}
